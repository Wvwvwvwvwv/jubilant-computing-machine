diff --git a/backend/core/routers/books.py b/backend/core/routers/books.py
index 5a7440c..482941e 100644
--- a/backend/core/routers/books.py
+++ b/backend/core/routers/books.py
@@ -1,83 +1,147 @@
-from fastapi import APIRouter, UploadFile, File, HTTPException
+from fastapi import APIRouter, UploadFile, File, HTTPException, Request
 from pathlib import Path
 import aiofiles
 import hashlib
-from typing import List
+import re
+from html import unescape
+import xml.etree.ElementTree as ET
+from typing import Optional, Tuple
 
 router = APIRouter()
 
 BOOKS_DIR = Path.home() / "roampal-android" / "data" / "books"
 BOOKS_DIR.mkdir(parents=True, exist_ok=True)
 
+ALLOWED_EXTENSIONS = {".txt", ".md", ".html", ".htm", ".fb2", ".pdf"}
+MAX_CHUNK_SIZE = 1800
+
+
+def _split_text(text: str, chunk_size: int = MAX_CHUNK_SIZE):
+    text = text.strip()
+    if not text:
+        return []
+    return [text[i : i + chunk_size] for i in range(0, len(text), chunk_size)]
+
+
+def _extract_text(content: bytes, suffix: str) -> Tuple[str, Optional[str]]:
+    suffix = suffix.lower()
+
+    if suffix in {".txt", ".md"}:
+        return content.decode("utf-8", errors="ignore"), None
+
+    if suffix in {".html", ".htm"}:
+        raw = content.decode("utf-8", errors="ignore")
+        raw = re.sub(r"<script[^>]*>.*?</script>", " ", raw, flags=re.IGNORECASE | re.DOTALL)
+        raw = re.sub(r"<style[^>]*>.*?</style>", " ", raw, flags=re.IGNORECASE | re.DOTALL)
+        text = re.sub(r"<[^>]+>", " ", raw)
+        return re.sub(r"\s+", " ", unescape(text)).strip(), None
+
+    if suffix == ".fb2":
+        xml_text = content.decode("utf-8", errors="ignore")
+        root = ET.fromstring(xml_text)
+        chunks = []
+        for node in root.iter():
+            if node.text and node.text.strip():
+                chunks.append(node.text.strip())
+        return "\n".join(chunks).strip(), None
+
+    if suffix == ".pdf":
+        try:
+            from pypdf import PdfReader
+        except Exception:
+            return "", "PDF parser unavailable (install pypdf==4.3.1)"
+
+        from io import BytesIO
+        try:
+            reader = PdfReader(BytesIO(content))
+            chunks = []
+            for page in reader.pages:
+                page_text = page.extract_text() or ""
+                if page_text.strip():
+                    chunks.append(page_text.strip())
+            text = "\n\n".join(chunks).strip()
+            if not text:
+                return "", "PDF uploaded, but no extractable text found (possibly scanned/image PDF)"
+            return text, None
+        except Exception as e:
+            raise HTTPException(status_code=400, detail=f"Некорректный PDF: {e}")
+
+    raise HTTPException(status_code=400, detail=f"Неподдерживаемый формат: {suffix}")
+
+
 @router.post("/upload")
-async def upload_book(file: UploadFile = File(...)):
-    """Загрузить книгу или текстовый файл"""
-    
-    if not file.filename.endswith(('.txt', '.md')):
-        raise HTTPException(status_code=400, detail="Только .txt и .md файлы")
-    
-    try:
-        # Генерация уникального ID
-        content = await file.read()
-        file_hash = hashlib.md5(content).hexdigest()[:8]
-        
-        # Сохранение файла
-        safe_filename = f"{file_hash}_{file.filename}"
-        file_path = BOOKS_DIR / safe_filename
-        
-        async with aiofiles.open(file_path, 'wb') as f:
-            await f.write(content)
-        
-        return {
-            "id": file_hash,
-            "filename": file.filename,
-            "size": len(content),
-            "status": "uploaded"
-        }
-        
-    except Exception as e:
-        raise HTTPException(status_code=500, detail=str(e))
+async def upload_book(file: UploadFile = File(...), req: Request = None):
+    suffix = Path(file.filename or "").suffix.lower()
+    if suffix not in ALLOWED_EXTENSIONS:
+        allowed = ", ".join(sorted(ALLOWED_EXTENSIONS))
+        raise HTTPException(status_code=400, detail=f"Поддерживаются форматы: {allowed}")
+
+    content = await file.read()
+    extracted, warning = _extract_text(content, suffix)
+
+    file_hash = hashlib.md5(content).hexdigest()[:8]
+    safe_filename = f"{file_hash}_{file.filename}"
+    file_path = BOOKS_DIR / safe_filename
+
+    async with aiofiles.open(file_path, "wb") as f:
+        await f.write(content)
+
+    memory_items = 0
+    if req is not None and hasattr(req.app.state, "memory_engine"):
+        memory_engine = req.app.state.memory_engine
+        for idx, chunk in enumerate(_split_text(extracted)):
+            await memory_engine.add_memory(
+                content=chunk,
+                metadata={"type": "book", "book_id": file_hash, "filename": file.filename, "chunk_index": idx, "source_format": suffix},
+            )
+            memory_items += 1
+
+    response = {
+        "id": file_hash,
+        "filename": file.filename,
+        "size": len(content),
+        "text_length": len(extracted),
+        "memory_items": memory_items,
+        "status": "uploaded",
+    }
+    if warning:
+        response["warning"] = warning
+    return response
+
 
 @router.get("/list")
 async def list_books():
-    """Список всех книг"""
-    
     books = []
     for file_path in BOOKS_DIR.glob("*"):
         if file_path.is_file():
             stat = file_path.stat()
-            books.append({
-                "id": file_path.stem.split("_")[0],
-                "filename": "_".join(file_path.stem.split("_")[1:]) + file_path.suffix,
-                "size": stat.st_size,
-                "modified": stat.st_mtime
-            })
-    
+            books.append(
+                {
+                    "id": file_path.stem.split("_")[0],
+                    "filename": "_".join(file_path.stem.split("_")[1:]) + file_path.suffix,
+                    "size": stat.st_size,
+                    "modified": stat.st_mtime,
+                }
+            )
     return {"books": books, "count": len(books)}
 
+
 @router.delete("/{book_id}")
 async def delete_book(book_id: str):
-    """Удалить книгу"""
-    
-    # Поиск файла по ID
     for file_path in BOOKS_DIR.glob(f"{book_id}_*"):
         file_path.unlink()
         return {"status": "deleted", "id": book_id}
-    
     raise HTTPException(status_code=404, detail="Книга не найдена")
 
+
 @router.get("/{book_id}/content")
 async def get_book_content(book_id: str):
-    """Получить содержимое книги"""
-    
     for file_path in BOOKS_DIR.glob(f"{book_id}_*"):
-        async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:
+        async with aiofiles.open(file_path, "rb") as f:
             content = await f.read()
-        
-        return {
-            "id": book_id,
-            "filename": file_path.name,
-            "content": content
-        }
-    
+        text, warning = _extract_text(content, file_path.suffix)
+        response = {"id": book_id, "filename": file_path.name, "content": text}
+        if warning:
+            response["warning"] = warning
+        return response
     raise HTTPException(status_code=404, detail="Книга не найдена")
diff --git a/backend/core/services/kobold_client.py b/backend/core/services/kobold_client.py
index 88aab2f..eb636d6 100644
--- a/backend/core/services/kobold_client.py
+++ b/backend/core/services/kobold_client.py
@@ -1,26 +1,25 @@
 import httpx
-from typing import List, Dict
+from typing import Any, List
 
 class KoboldClient:
     """Клиент для KoboldCpp API"""
-    
+
     def __init__(self, base_url: str = "http://localhost:5001"):
         self.base_url = base_url
         self.client = httpx.AsyncClient(timeout=120.0)
-    
+
     async def generate(
         self,
-        messages: List[Dict],
+        messages: List[Any],
         max_tokens: int = 512,
         temperature: float = 0.7,
         top_p: float = 0.9,
         top_k: int = 40
     ) -> str:
         """Генерация текста через KoboldCpp"""
-        
-        # Форматирование сообщений в промпт
+
         prompt = self._format_messages(messages)
-        
+
         payload = {
             "prompt": prompt,
             "max_length": max_tokens,
@@ -30,46 +29,55 @@ class KoboldClient:
             "rep_pen": 1.1,
             "stop_sequence": ["</s>", "User:", "Assistant:"]
         }
-        
+
         try:
             response = await self.client.post(
                 f"{self.base_url}/api/v1/generate",
                 json=payload
             )
             response.raise_for_status()
-            
+
             result = response.json()
             return result["results"][0]["text"].strip()
-            
+
         except httpx.HTTPError as e:
             raise Exception(f"KoboldCpp error: {str(e)}")
-    
-    def _format_messages(self, messages: List[Dict]) -> str:
+
+    @staticmethod
+    def _msg_field(msg: Any, field: str, default: str = "") -> str:
+        """Безопасно получить поле сообщения из dict или Pydantic-модели."""
+        if isinstance(msg, dict):
+            value = msg.get(field, default)
+        else:
+            value = getattr(msg, field, default)
+        return value if isinstance(value, str) else str(value)
+
+    def _format_messages(self, messages: List[Any]) -> str:
         """Форматирование сообщений в промпт"""
-        
+
         formatted = []
         for msg in messages:
-            role = msg.get("role", "user")
-            content = msg.get("content", "")
-            
+            role = self._msg_field(msg, "role", "user")
+            content = self._msg_field(msg, "content", "")
+
             if role == "system":
                 formatted.append(f"System: {content}")
             elif role == "user":
                 formatted.append(f"User: {content}")
             elif role == "assistant":
                 formatted.append(f"Assistant: {content}")
-        
+
         formatted.append("Assistant:")
         return "\n\n".join(formatted)
-    
+
     async def check_health(self) -> bool:
         """Проверка доступности KoboldCpp"""
-        
+
         try:
             response = await self.client.get(f"{self.base_url}/api/v1/model")
             return response.status_code == 200
-        except:
+        except Exception:
             return False
-    
+
     async def close(self):
         await self.client.aclose()
diff --git a/frontend/src/api/client.ts b/frontend/src/api/client.ts
index a752ab0..03177e3 100644
--- a/frontend/src/api/client.ts
+++ b/frontend/src/api/client.ts
@@ -1,5 +1,19 @@
 import axios from 'axios'
 
+
+export function extractApiError(error: any): string {
+  const status = error?.response?.status
+  const detail = error?.response?.data?.detail
+
+  if (detail && typeof detail === 'string') return detail
+  if (status === 503) return 'Сервис временно недоступен. Проверьте запуск backend/embeddings.'
+  if (status === 504 || error?.code === 'ECONNABORTED') return 'Превышен таймаут ответа сервера.'
+  if (!error?.response) return 'Ошибка соединения с сервером.'
+
+  return `Ошибка API (${status ?? 'unknown'})`
+}
+
+
 const api = axios.create({
   baseURL: '/api',
   timeout: 120000
diff --git a/frontend/src/pages/ChatPage.tsx b/frontend/src/pages/ChatPage.tsx
index ebafb88..13f9b81 100644
--- a/frontend/src/pages/ChatPage.tsx
+++ b/frontend/src/pages/ChatPage.tsx
@@ -1,187 +1,267 @@
-import { useState } from 'react'
-import { Send, ThumbsUp, ThumbsDown } from 'lucide-react'
-import { chatAPI } from '../api/client'
+import { useEffect, useMemo, useRef, useState } from 'react'
+import { Send, ThumbsUp, ThumbsDown, Plus, Upload, Trash2, MessageSquare } from 'lucide-react'
+import { booksAPI, chatAPI, extractApiError } from '../api/client'
 
 interface Message {
   role: 'user' | 'assistant'
   content: string
-  id?: string
+  id: string
+  interactionId?: string
+}
+
+interface Conversation {
+  id: string
+  title: string
+  messages: Message[]
+  useMemory: boolean
+  updatedAt: number
+}
+
+interface BookItem {
+  id: string
+  filename: string
+  size: number
+  modified: number
+}
+
+const STORAGE_KEY = 'roampal_chat_conversations'
+const ACTIVE_KEY = 'roampal_chat_active_id'
+
+function createConversation(title: string = 'Новый диалог'): Conversation {
+  const now = Date.now()
+  return { id: `${now}-${Math.random().toString(16).slice(2)}`, title, messages: [], useMemory: true, updatedAt: now }
+}
+
+function createMessage(role: Message['role'], content: string, options?: { id?: string; interactionId?: string }): Message {
+  return { role, content, id: options?.id ?? `${Date.now()}-${Math.random().toString(16).slice(2)}`, interactionId: options?.interactionId }
+}
+
+function normalizeConversation(raw: any): Conversation | null {
+  if (!raw || typeof raw !== 'object' || typeof raw.id !== 'string') return null
+  const messages = Array.isArray(raw.messages)
+    ? raw.messages
+        .map((message: any) => {
+          if (!message || typeof message !== 'object') return null
+          if ((message.role !== 'user' && message.role !== 'assistant') || typeof message.content !== 'string') return null
+          return createMessage(message.role, message.content, {
+            id: typeof message.id === 'string' ? message.id : undefined,
+            interactionId: typeof message.interactionId === 'string' ? message.interactionId : undefined
+          })
+        })
+        .filter((m: Message | null): m is Message => Boolean(m))
+    : []
+  return {
+    id: raw.id,
+    title: typeof raw.title === 'string' ? raw.title : 'Новый диалог',
+    messages,
+    useMemory: typeof raw.useMemory === 'boolean' ? raw.useMemory : true,
+    updatedAt: typeof raw.updatedAt === 'number' ? raw.updatedAt : Date.now()
+  }
 }
 
 export default function ChatPage() {
-  const [messages, setMessages] = useState<Message[]>([])
+  const [conversations, setConversations] = useState<Conversation[]>([])
+  const [activeConversationId, setActiveConversationId] = useState('')
   const [input, setInput] = useState('')
   const [loading, setLoading] = useState(false)
-  const [useMemory, setUseMemory] = useState(true)
+  const [showMenu, setShowMenu] = useState(false)
+  const [showDialogs, setShowDialogs] = useState(true)
+  const [showBooks, setShowBooks] = useState(false)
+  const [books, setBooks] = useState<BookItem[]>([])
+  const [menuError, setMenuError] = useState('')
+  const fileInputRef = useRef<HTMLInputElement>(null)
 
-  const sendMessage = async () => {
-    if (!input.trim() || loading) return
+  useEffect(() => {
+    try {
+      const raw = localStorage.getItem(STORAGE_KEY)
+      const parsed = raw ? JSON.parse(raw) : []
+      const valid = Array.isArray(parsed) ? parsed.map(normalizeConversation).filter((c): c is Conversation => Boolean(c)) : []
+      if (valid.length > 0) {
+        setConversations(valid)
+        const storedActive = localStorage.getItem(ACTIVE_KEY)
+        const exists = storedActive && valid.some(c => c.id === storedActive)
+        setActiveConversationId(exists ? storedActive! : valid[0].id)
+      } else {
+        const initial = createConversation('Диалог 1')
+        setConversations([initial]); setActiveConversationId(initial.id)
+      }
+    } catch {
+      const initial = createConversation('Диалог 1')
+      setConversations([initial]); setActiveConversationId(initial.id)
+    }
+  }, [])
+
+  useEffect(() => {
+    const sync = (event: StorageEvent) => {
+      if (event.key !== STORAGE_KEY || event.storageArea !== localStorage) return
+      try {
+        const parsed = event.newValue ? JSON.parse(event.newValue) : []
+        const synced = Array.isArray(parsed) ? parsed.map(normalizeConversation).filter((c): c is Conversation => Boolean(c)) : []
+        if (!synced.length) return
+        setConversations(synced)
+        setActiveConversationId(current => (synced.some(c => c.id === current) ? current : synced[0].id))
+      } catch {}
+    }
+    window.addEventListener('storage', sync)
+    return () => window.removeEventListener('storage', sync)
+  }, [])
+
+  useEffect(() => { if (conversations.length) localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations)) }, [conversations])
+  useEffect(() => { if (activeConversationId) localStorage.setItem(ACTIVE_KEY, activeConversationId) }, [activeConversationId])
 
-    const userMessage: Message = { role: 'user', content: input }
-    setMessages(prev => [...prev, userMessage])
-    setInput('')
-    setLoading(true)
+  const activeConversation = useMemo(() => conversations.find(c => c.id === activeConversationId) ?? conversations[0], [conversations, activeConversationId])
+  const dialogList = useMemo(() => [...conversations].sort((a, b) => b.updatedAt - a.updatedAt), [conversations])
 
+  const updateActiveConversation = (updater: (conv: Conversation) => Conversation) => {
+    if (!activeConversation) return
+    setConversations(prev => prev.map(c => (c.id === activeConversation.id ? updater(c) : c)))
+  }
+
+  const sendMessage = async () => {
+    if (!input.trim() || loading || !activeConversation) return
+    const userMessage = createMessage('user', input)
+    const nextMessages = [...activeConversation.messages, userMessage]
+    updateActiveConversation(c => ({
+      ...c,
+      messages: nextMessages,
+      title: c.messages.length === 0 ? userMessage.content.slice(0, 40) || 'Новый диалог' : c.title,
+      updatedAt: Date.now()
+    }))
+    setInput(''); setLoading(true)
     try {
-      const response = await chatAPI.send([...messages, userMessage], useMemory)
-      
-      setMessages(prev => [...prev, {
-        role: 'assistant',
-        content: response.response,
-        id: response.interaction_id
-      }])
+      const response = await chatAPI.send(nextMessages, activeConversation.useMemory)
+      updateActiveConversation(c => ({
+        ...c,
+        messages: [...c.messages, createMessage('assistant', response.response, { interactionId: response.interaction_id })],
+        updatedAt: Date.now()
+      }))
     } catch (error: any) {
-      console.error('Chat error:', error)
-      const detail = error?.response?.data?.detail
-      setMessages(prev => [...prev, {
-        role: 'assistant',
-        content: detail ? `❌ ${detail}` : '❌ Ошибка соединения с сервером'
-      }])
-    } finally {
-      setLoading(false)
-    }
+      updateActiveConversation(c => ({
+        ...c,
+        messages: [...c.messages, createMessage('assistant', `❌ ${extractApiError(error)}`)],
+        updatedAt: Date.now()
+      }))
+    } finally { setLoading(false) }
   }
 
-  const handleFeedback = async (messageId: string, helpful: boolean) => {
-    try {
-      await chatAPI.feedback(messageId, helpful)
-    } catch (error) {
-      console.error('Feedback error:', error)
-    }
+  const handleFeedback = async (messageId: string | undefined, helpful: boolean) => {
+    if (!messageId) return
+    try { await chatAPI.feedback(messageId, helpful) } catch {}
+  }
+
+  const createNewDialog = () => {
+    const fresh = createConversation(`Диалог ${conversations.length + 1}`)
+    setConversations(prev => [fresh, ...prev]); setActiveConversationId(fresh.id)
+  }
+
+  const removeDialog = (dialogId: string) => {
+    if (conversations.length <= 1) return setMenuError('Нельзя удалить последний диалог.')
+    const target = conversations.find(d => d.id === dialogId)
+    if (!target) return
+    if (!window.confirm(`Удалить диалог "${target.title || 'Без названия'}"?`)) return
+    const next = conversations.filter(c => c.id !== dialogId)
+    setConversations(next)
+    if (activeConversationId === dialogId) setActiveConversationId(next[0].id)
+  }
+
+  const loadBooks = async () => {
+    try { const data = await booksAPI.list(); setBooks(data.books || []); setMenuError('') }
+    catch (error: any) { setMenuError(extractApiError(error)) }
+  }
+
+  const openBooksPanel = async () => { setShowBooks(true); setShowDialogs(false); await loadBooks() }
+
+  const uploadBook = async (file?: File) => {
+    if (!file) return
+    try { await booksAPI.upload(file); await loadBooks(); setMenuError('') }
+    catch (error: any) { setMenuError(extractApiError(error)) }
+  }
+
+  const deleteBook = async (bookId: string) => {
+    const target = books.find(b => b.id === bookId)
+    if (!target) return
+    if (!window.confirm(`Удалить книгу "${target.filename}"?`)) return
+    try { await booksAPI.delete(bookId); await loadBooks(); setMenuError('') }
+    catch (error: any) { setMenuError(extractApiError(error)) }
   }
 
   return (
-    <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
-      {/* Messages */}
-      <div style={{
-        flex: 1,
-        overflowY: 'auto',
-        padding: '1rem',
-        display: 'flex',
-        flexDirection: 'column',
-        gap: '1rem'
-      }}>
-        {messages.map((msg, idx) => (
-          <div
-            key={idx}
-            style={{
-              alignSelf: msg.role === 'user' ? 'flex-end' : 'flex-start',
-              maxWidth: '80%'
-            }}
-          >
-            <div style={{
-              background: msg.role === 'user' ? '#3b82f6' : '#1f1f1f',
-              padding: '0.75rem 1rem',
-              borderRadius: '1rem',
-              wordWrap: 'break-word'
-            }}>
+    <div style={{ display: 'flex', flexDirection: 'column', height: '100%', position: 'relative' }}>
+      <div style={{ padding: '0.75rem 1rem', borderBottom: '1px solid #222', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
+        <div style={{ color: '#aaa', fontSize: '0.85rem', maxWidth: '80%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
+          {activeConversation?.title || 'Диалог'}
+        </div>
+      </div>
+
+      <div style={{ flex: 1, overflowY: 'auto', padding: '1rem', display: 'flex', flexDirection: 'column', gap: '1rem' }}>
+        {(activeConversation?.messages || []).map((msg) => (
+          <div key={msg.id} style={{ alignSelf: msg.role === 'user' ? 'flex-end' : 'flex-start', maxWidth: '80%' }}>
+            <div style={{ background: msg.role === 'user' ? '#3b82f6' : '#1f1f1f', padding: '0.75rem 1rem', borderRadius: '1rem', wordWrap: 'break-word' }}>
               {msg.content}
             </div>
-            
-            {msg.role === 'assistant' && msg.id && (
-              <div style={{
-                display: 'flex',
-                gap: '0.5rem',
-                marginTop: '0.5rem',
-                fontSize: '0.875rem'
-              }}>
-                <button
-                  onClick={() => handleFeedback(msg.id!, true)}
-                  style={{
-                    background: 'transparent',
-                    border: '1px solid #333',
-                    borderRadius: '0.5rem',
-                    padding: '0.25rem 0.5rem',
-                    color: '#888',
-                    cursor: 'pointer'
-                  }}
-                >
-                  <ThumbsUp size={14} />
-                </button>
-                <button
-                  onClick={() => handleFeedback(msg.id!, false)}
-                  style={{
-                    background: 'transparent',
-                    border: '1px solid #333',
-                    borderRadius: '0.5rem',
-                    padding: '0.25rem 0.5rem',
-                    color: '#888',
-                    cursor: 'pointer'
-                  }}
-                >
-                  <ThumbsDown size={14} />
-                </button>
+            {msg.role === 'assistant' && msg.interactionId && (
+              <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem', fontSize: '0.875rem' }}>
+                <button onClick={() => handleFeedback(msg.interactionId, true)} style={{ background: 'transparent', border: '1px solid #333', borderRadius: '0.5rem', padding: '0.25rem 0.5rem', color: '#888', cursor: 'pointer' }}><ThumbsUp size={14} /></button>
+                <button onClick={() => handleFeedback(msg.interactionId, false)} style={{ background: 'transparent', border: '1px solid #333', borderRadius: '0.5rem', padding: '0.25rem 0.5rem', color: '#888', cursor: 'pointer' }}><ThumbsDown size={14} /></button>
               </div>
             )}
           </div>
         ))}
-        
-        {loading && (
-          <div style={{ alignSelf: 'flex-start' }}>
-            <div style={{
-              background: '#1f1f1f',
-              padding: '0.75rem 1rem',
-              borderRadius: '1rem'
-            }}>
-              Думаю...
-            </div>
-          </div>
-        )}
+        {loading && <div style={{ alignSelf: 'flex-start' }}><div style={{ background: '#1f1f1f', padding: '0.75rem 1rem', borderRadius: '1rem' }}>Думаю...</div></div>}
       </div>
 
-      {/* Input */}
-      <div style={{
-        padding: '1rem',
-        borderTop: '1px solid #222',
-        display: 'flex',
-        gap: '0.5rem',
-        alignItems: 'center'
-      }}>
+      <div style={{ padding: '1rem', borderTop: '1px solid #222', display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
         <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.875rem' }}>
-          <input
-            type="checkbox"
-            checked={useMemory}
-            onChange={(e) => setUseMemory(e.target.checked)}
-          />
+          <input type="checkbox" checked={activeConversation?.useMemory ?? true} onChange={(e) => updateActiveConversation(c => ({ ...c, useMemory: e.target.checked, updatedAt: Date.now() }))} />
           Память
         </label>
-        
-        <input
-          type="text"
-          value={input}
-          onChange={(e) => setInput(e.target.value)}
-          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
-          placeholder="Сообщение..."
-          style={{
-            flex: 1,
-            background: '#1a1a1a',
-            border: '1px solid #333',
-            borderRadius: '1.5rem',
-            padding: '0.75rem 1rem',
-            color: '#fff',
-            outline: 'none'
-          }}
-        />
-        
-        <button
-          onClick={sendMessage}
-          disabled={loading || !input.trim()}
-          style={{
-            background: '#3b82f6',
-            border: 'none',
-            borderRadius: '50%',
-            width: '3rem',
-            height: '3rem',
-            display: 'flex',
-            alignItems: 'center',
-            justifyContent: 'center',
-            cursor: loading ? 'not-allowed' : 'pointer',
-            opacity: loading ? 0.5 : 1
-          }}
-        >
-          <Send size={20} />
-        </button>
+        <input type="text" value={input} onChange={(e) => setInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && sendMessage()} placeholder="Сообщение..." style={{ flex: 1, background: '#1a1a1a', border: '1px solid #333', borderRadius: '1.5rem', padding: '0.75rem 1rem', color: '#fff', outline: 'none' }} />
+        <button onClick={sendMessage} disabled={loading || !input.trim()} style={{ background: '#3b82f6', border: 'none', borderRadius: '50%', width: '3rem', height: '3rem', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: loading ? 'not-allowed' : 'pointer', opacity: loading ? 0.5 : 1 }}><Send size={20} /></button>
       </div>
+
+      {showMenu && (
+        <div style={{ position: 'absolute', right: '1rem', bottom: '5.5rem', width: '20rem', maxHeight: '60%', overflowY: 'auto', background: '#111', border: '1px solid #333', borderRadius: '0.75rem', padding: '0.75rem', boxShadow: '0 10px 25px rgba(0,0,0,.45)', zIndex: 10, display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
+          <div style={{ display: 'flex', gap: '0.5rem' }}>
+            <button onClick={() => { createNewDialog(); setShowDialogs(true); setShowBooks(false); setMenuError('') }} style={{ flex: 1, background: '#2563eb', border: 'none', color: '#fff', borderRadius: '0.5rem', padding: '0.45rem', cursor: 'pointer' }}>+ Новый диалог</button>
+            <button onClick={() => { setShowDialogs(true); setShowBooks(false); setMenuError('') }} style={{ background: '#1f2937', border: '1px solid #374151', color: '#fff', borderRadius: '0.5rem', padding: '0.45rem', cursor: 'pointer' }} title="Диалоги"><MessageSquare size={16} /></button>
+            <button onClick={openBooksPanel} style={{ background: '#1f2937', border: '1px solid #374151', color: '#fff', borderRadius: '0.5rem', padding: '0.45rem', cursor: 'pointer' }} title="Литература"><Upload size={16} /></button>
+          </div>
+
+          {menuError && <div style={{ color: '#fca5a5', fontSize: '0.8rem' }}>❌ {menuError}</div>}
+
+          {showDialogs && (
+            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.4rem' }}>
+              {dialogList.map(dialog => (
+                <div key={dialog.id} style={{ display: 'flex', gap: '0.4rem' }}>
+                  <button onClick={() => { setActiveConversationId(dialog.id); setShowMenu(false) }} style={{ flex: 1, background: dialog.id === activeConversation?.id ? '#1e3a8a' : '#1a1a1a', border: '1px solid #333', borderRadius: '0.5rem', color: '#fff', padding: '0.45rem', textAlign: 'left', cursor: 'pointer' }}>{dialog.title || 'Без названия'}</button>
+                  <button onClick={() => removeDialog(dialog.id)} style={{ background: '#2b1111', border: '1px solid #7f1d1d', borderRadius: '0.5rem', color: '#fca5a5', padding: '0.35rem 0.5rem', cursor: 'pointer' }} title="Удалить диалог"><Trash2 size={14} /></button>
+                </div>
+              ))}
+            </div>
+          )}
+
+          {showBooks && (
+            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.4rem' }}>
+              <button onClick={() => fileInputRef.current?.click()} style={{ background: '#2563eb', border: 'none', color: '#fff', borderRadius: '0.5rem', padding: '0.45rem', cursor: 'pointer' }}>Загрузить литературу</button>
+              <input ref={fileInputRef} type="file" accept=".txt,.md,.html,.htm,.fb2,.pdf,text/plain,text/markdown,text/html,application/xhtml+xml,application/pdf,application/xml,text/xml,*/*" style={{ display: 'none' }} onChange={(e) => { uploadBook(e.target.files?.[0]); e.currentTarget.value = '' }} />
+              {books.map(book => (
+                <div key={book.id} style={{ display: 'flex', gap: '0.4rem', alignItems: 'center' }}>
+                  <div style={{ flex: 1, background: '#1a1a1a', border: '1px solid #333', borderRadius: '0.5rem', padding: '0.45rem', color: '#ddd', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{book.filename}</div>
+                  <button onClick={() => deleteBook(book.id)} style={{ background: '#2b1111', border: '1px solid #7f1d1d', borderRadius: '0.5rem', color: '#fca5a5', padding: '0.35rem 0.5rem', cursor: 'pointer' }} title="Удалить литературу"><Trash2 size={14} /></button>
+                </div>
+              ))}
+            </div>
+          )}
+        </div>
+      )}
+
+      <button
+        onClick={() => { setShowMenu(prev => !prev); if (!showMenu) { setShowDialogs(true); setShowBooks(false); setMenuError('') } }}
+        style={{ position: 'absolute', right: '1rem', bottom: '1rem', width: '3.2rem', height: '3.2rem', borderRadius: '50%', border: 'none', background: '#2563eb', color: '#fff', display: 'flex', alignItems: 'center', justifyContent: 'center', boxShadow: '0 8px 20px rgba(37,99,235,.45)', cursor: 'pointer', zIndex: 11 }}
+        title="Меню"
+      >
+        <Plus size={22} />
+      </button>
     </div>
   )
 }
diff --git a/frontend/src/pages/MemoryPage.tsx b/frontend/src/pages/MemoryPage.tsx
index 1cd3329..be3a90f 100644
--- a/frontend/src/pages/MemoryPage.tsx
+++ b/frontend/src/pages/MemoryPage.tsx
@@ -172,7 +172,7 @@ export default function MemoryPage() {
             Загрузить
             <input
               type="file"
-              accept=".txt,.md"
+              accept=".txt,.md,.html,.htm,.fb2,.pdf,text/plain,text/markdown,text/html,application/xhtml+xml,application/pdf,application/xml,text/xml,*/*"
               onChange={handleUpload}
               style={{ display: 'none' }}
             />
